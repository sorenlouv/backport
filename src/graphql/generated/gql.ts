/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
  '\n    mutation DisablePullRequestAutoMerge($pullRequestId: ID!) {\n      disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  ': typeof types.DisablePullRequestAutoMergeDocument;
  '\n    mutation EnablePullRequestAutoMerge(\n      $pullRequestId: ID!\n      $mergeMethod: PullRequestMergeMethod!\n    ) {\n      enablePullRequestAutoMerge(\n        input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }\n      ) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  ': typeof types.EnablePullRequestAutoMergeDocument;
  '\n    query AuthorId($author: String!) {\n      user(login: $author) {\n        id\n      }\n    }\n  ': typeof types.AuthorIdDocument;
  '\n    query CommitByPullNumber(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          # used to determine if "Rebase and Merge" strategy was used\n          commits(last: 1) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            oid\n\n            # used to determine if "Rebase and Merge" strategy was used\n            committedDate\n            history(first: 2) {\n              edges {\n                node {\n                  message\n                  committedDate\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ': typeof types.CommitByPullNumberDocument;
  '\n    query CommitsBySha($repoOwner: String!, $repoName: String!, $sha: String!) {\n      repository(owner: $repoOwner, name: $repoName) {\n        object(expression: $sha) {\n          ...SourceCommitWithTargetPullRequestFragment\n        }\n      }\n    }\n  ': typeof types.CommitsByShaDocument;
  '\n    query CommitsByAuthor(\n      $authorId: ID\n      $commitPath: String\n      $dateSince: GitTimestamp\n      $dateUntil: GitTimestamp\n      $maxNumber: Int!\n      $repoName: String!\n      $repoOwner: String!\n      $sourceBranch: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $sourceBranch) {\n          target {\n            ... on Commit {\n              history(\n                first: $maxNumber\n                author: { id: $authorId }\n                path: $commitPath\n                since: $dateSince\n                until: $dateUntil\n              ) {\n                edges {\n                  node {\n                    ...SourceCommitWithTargetPullRequestFragment\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ': typeof types.CommitsByAuthorDocument;
  '\n    query CommitsForRebaseAndMergeStrategy(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n      $commitsTotalCount: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          number\n          commits(first: $commitsTotalCount) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            committedDate\n            history(first: $commitsTotalCount) {\n              edges {\n                node {\n                  oid\n                  message\n                  committedDate\n                  associatedPullRequests(first: 1) {\n                    edges {\n                      node {\n                        number\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ': typeof types.CommitsForRebaseAndMergeStrategyDocument;
  '\n    query PullRequestBySearchQuery($query: String!, $maxNumber: Int!) {\n      search(query: $query, type: ISSUE, first: $maxNumber) {\n        nodes {\n          ... on PullRequest {\n            mergeCommit {\n              ...SourceCommitWithTargetPullRequestFragment\n            }\n          }\n        }\n      }\n    }\n  ': typeof types.PullRequestBySearchQueryDocument;
  '\n    query ExistingPullRequest(\n      $repoOwner: String!\n      $repoName: String!\n      $base: String!\n      $head: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        name\n        ref(qualifiedName: $head) {\n          name\n          associatedPullRequests(\n            first: 1\n            states: OPEN\n            baseRefName: $base\n            headRefName: $head\n          ) {\n            edges {\n              node {\n                number\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  ': typeof types.ExistingPullRequestDocument;
  '\n    query PullRequestAutoMergeMethod(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          autoMergeRequest {\n            enabledAt\n            mergeMethod\n          }\n        }\n      }\n    }\n  ': typeof types.PullRequestAutoMergeMethodDocument;
  '\n    query PullRequestId(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          id\n        }\n      }\n    }\n  ': typeof types.PullRequestIdDocument;
  '\n      query GithubConfigOptions($repoOwner: String!, $repoName: String!) {\n        viewer {\n          login\n        }\n        repository(owner: $repoOwner, name: $repoName) {\n          # check to see if a branch named "backport" exists\n          illegalBackportBranch: ref(qualifiedName: "refs/heads/backport") {\n            id\n          }\n          isPrivate\n          defaultBranchRef {\n            name\n            target {\n              ...RemoteConfigHistoryFragment\n            }\n          }\n        }\n      }\n    ': typeof types.GithubConfigOptionsDocument;
  '\n      query RepoOwnerAndName($repoOwner: String!, $repoName: String!) {\n        repository(owner: $repoOwner, name: $repoName) {\n          isFork\n          name\n          owner {\n            login\n          }\n          parent {\n            owner {\n              login\n            }\n          }\n        }\n      }\n    ': typeof types.RepoOwnerAndNameDocument;
  '\n  query GetViewer {\n    viewer {\n      login\n    }\n  }\n': typeof types.GetViewerDocument;
  '\n  query GetRepo($repoOwner: String!, $repoName: String!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      name\n    }\n  }\n': typeof types.GetRepoDocument;
  '\n    query GetBranchId(\n      $repoOwner: String!\n      $repoName: String!\n      $branchName: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $branchName) {\n          id\n        }\n      }\n    }\n  ': typeof types.GetBranchIdDocument;
  '\n  fragment RemoteConfigHistoryFragment on Commit {\n    remoteConfigHistory: history(first: 1, path: ".backportrc.json") {\n      edges {\n        remoteConfig: node {\n          committedDate\n          file(path: ".backportrc.json") {\n            ... on TreeEntry {\n              object {\n                ... on Blob {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n': typeof types.RemoteConfigHistoryFragmentFragmentDoc;
  '\n  fragment SourceCommitWithTargetPullRequestFragment on Commit {\n    # Source Commit\n    repository {\n      name\n      owner {\n        login\n      }\n    }\n    sha: oid\n    message\n    committedDate\n\n    author {\n      name\n      email\n    }\n\n    # Source pull request: PR where source commit was merged in\n    associatedPullRequests(first: 1) {\n      edges {\n        node {\n          title\n          url\n          number\n          labels(first: 50) {\n            nodes {\n              name\n            }\n          }\n          baseRefName\n\n          # source merge commit (the commit that actually went into the source branch)\n          mergeCommit {\n            ...RemoteConfigHistoryFragment\n            sha: oid\n            message\n          }\n\n          # (possible) backport pull requests referenced in the source pull request\n          timelineItems(last: 20, itemTypes: CROSS_REFERENCED_EVENT) {\n            edges {\n              node {\n                ... on CrossReferencedEvent {\n                  targetPullRequest: source {\n                    __typename\n\n                    # Target PRs (backport PRs)\n                    ... on PullRequest {\n                      # target merge commit: the backport commit that was merged into the target branch\n                      targetMergeCommit: mergeCommit {\n                        sha: oid\n                        message\n                      }\n                      repository {\n                        name\n                        owner {\n                          login\n                        }\n                      }\n                      url\n                      title\n                      state\n                      baseRefName\n                      number\n                      commits(first: 20) {\n                        edges {\n                          node {\n                            targetCommit: commit {\n                              message\n                              sha: oid\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n': typeof types.SourceCommitWithTargetPullRequestFragmentFragmentDoc;
};
const documents: Documents = {
  '\n    mutation DisablePullRequestAutoMerge($pullRequestId: ID!) {\n      disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  ':
    types.DisablePullRequestAutoMergeDocument,
  '\n    mutation EnablePullRequestAutoMerge(\n      $pullRequestId: ID!\n      $mergeMethod: PullRequestMergeMethod!\n    ) {\n      enablePullRequestAutoMerge(\n        input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }\n      ) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  ':
    types.EnablePullRequestAutoMergeDocument,
  '\n    query AuthorId($author: String!) {\n      user(login: $author) {\n        id\n      }\n    }\n  ':
    types.AuthorIdDocument,
  '\n    query CommitByPullNumber(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          # used to determine if "Rebase and Merge" strategy was used\n          commits(last: 1) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            oid\n\n            # used to determine if "Rebase and Merge" strategy was used\n            committedDate\n            history(first: 2) {\n              edges {\n                node {\n                  message\n                  committedDate\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ':
    types.CommitByPullNumberDocument,
  '\n    query CommitsBySha($repoOwner: String!, $repoName: String!, $sha: String!) {\n      repository(owner: $repoOwner, name: $repoName) {\n        object(expression: $sha) {\n          ...SourceCommitWithTargetPullRequestFragment\n        }\n      }\n    }\n  ':
    types.CommitsByShaDocument,
  '\n    query CommitsByAuthor(\n      $authorId: ID\n      $commitPath: String\n      $dateSince: GitTimestamp\n      $dateUntil: GitTimestamp\n      $maxNumber: Int!\n      $repoName: String!\n      $repoOwner: String!\n      $sourceBranch: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $sourceBranch) {\n          target {\n            ... on Commit {\n              history(\n                first: $maxNumber\n                author: { id: $authorId }\n                path: $commitPath\n                since: $dateSince\n                until: $dateUntil\n              ) {\n                edges {\n                  node {\n                    ...SourceCommitWithTargetPullRequestFragment\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ':
    types.CommitsByAuthorDocument,
  '\n    query CommitsForRebaseAndMergeStrategy(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n      $commitsTotalCount: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          number\n          commits(first: $commitsTotalCount) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            committedDate\n            history(first: $commitsTotalCount) {\n              edges {\n                node {\n                  oid\n                  message\n                  committedDate\n                  associatedPullRequests(first: 1) {\n                    edges {\n                      node {\n                        number\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ':
    types.CommitsForRebaseAndMergeStrategyDocument,
  '\n    query PullRequestBySearchQuery($query: String!, $maxNumber: Int!) {\n      search(query: $query, type: ISSUE, first: $maxNumber) {\n        nodes {\n          ... on PullRequest {\n            mergeCommit {\n              ...SourceCommitWithTargetPullRequestFragment\n            }\n          }\n        }\n      }\n    }\n  ':
    types.PullRequestBySearchQueryDocument,
  '\n    query ExistingPullRequest(\n      $repoOwner: String!\n      $repoName: String!\n      $base: String!\n      $head: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        name\n        ref(qualifiedName: $head) {\n          name\n          associatedPullRequests(\n            first: 1\n            states: OPEN\n            baseRefName: $base\n            headRefName: $head\n          ) {\n            edges {\n              node {\n                number\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  ':
    types.ExistingPullRequestDocument,
  '\n    query PullRequestAutoMergeMethod(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          autoMergeRequest {\n            enabledAt\n            mergeMethod\n          }\n        }\n      }\n    }\n  ':
    types.PullRequestAutoMergeMethodDocument,
  '\n    query PullRequestId(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          id\n        }\n      }\n    }\n  ':
    types.PullRequestIdDocument,
  '\n      query GithubConfigOptions($repoOwner: String!, $repoName: String!) {\n        viewer {\n          login\n        }\n        repository(owner: $repoOwner, name: $repoName) {\n          # check to see if a branch named "backport" exists\n          illegalBackportBranch: ref(qualifiedName: "refs/heads/backport") {\n            id\n          }\n          isPrivate\n          defaultBranchRef {\n            name\n            target {\n              ...RemoteConfigHistoryFragment\n            }\n          }\n        }\n      }\n    ':
    types.GithubConfigOptionsDocument,
  '\n      query RepoOwnerAndName($repoOwner: String!, $repoName: String!) {\n        repository(owner: $repoOwner, name: $repoName) {\n          isFork\n          name\n          owner {\n            login\n          }\n          parent {\n            owner {\n              login\n            }\n          }\n        }\n      }\n    ':
    types.RepoOwnerAndNameDocument,
  '\n  query GetViewer {\n    viewer {\n      login\n    }\n  }\n':
    types.GetViewerDocument,
  '\n  query GetRepo($repoOwner: String!, $repoName: String!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      name\n    }\n  }\n':
    types.GetRepoDocument,
  '\n    query GetBranchId(\n      $repoOwner: String!\n      $repoName: String!\n      $branchName: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $branchName) {\n          id\n        }\n      }\n    }\n  ':
    types.GetBranchIdDocument,
  '\n  fragment RemoteConfigHistoryFragment on Commit {\n    remoteConfigHistory: history(first: 1, path: ".backportrc.json") {\n      edges {\n        remoteConfig: node {\n          committedDate\n          file(path: ".backportrc.json") {\n            ... on TreeEntry {\n              object {\n                ... on Blob {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n':
    types.RemoteConfigHistoryFragmentFragmentDoc,
  '\n  fragment SourceCommitWithTargetPullRequestFragment on Commit {\n    # Source Commit\n    repository {\n      name\n      owner {\n        login\n      }\n    }\n    sha: oid\n    message\n    committedDate\n\n    author {\n      name\n      email\n    }\n\n    # Source pull request: PR where source commit was merged in\n    associatedPullRequests(first: 1) {\n      edges {\n        node {\n          title\n          url\n          number\n          labels(first: 50) {\n            nodes {\n              name\n            }\n          }\n          baseRefName\n\n          # source merge commit (the commit that actually went into the source branch)\n          mergeCommit {\n            ...RemoteConfigHistoryFragment\n            sha: oid\n            message\n          }\n\n          # (possible) backport pull requests referenced in the source pull request\n          timelineItems(last: 20, itemTypes: CROSS_REFERENCED_EVENT) {\n            edges {\n              node {\n                ... on CrossReferencedEvent {\n                  targetPullRequest: source {\n                    __typename\n\n                    # Target PRs (backport PRs)\n                    ... on PullRequest {\n                      # target merge commit: the backport commit that was merged into the target branch\n                      targetMergeCommit: mergeCommit {\n                        sha: oid\n                        message\n                      }\n                      repository {\n                        name\n                        owner {\n                          login\n                        }\n                      }\n                      url\n                      title\n                      state\n                      baseRefName\n                      number\n                      commits(first: 20) {\n                        edges {\n                          node {\n                            targetCommit: commit {\n                              message\n                              sha: oid\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n':
    types.SourceCommitWithTargetPullRequestFragmentFragmentDoc,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    mutation DisablePullRequestAutoMerge($pullRequestId: ID!) {\n      disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    mutation DisablePullRequestAutoMerge($pullRequestId: ID!) {\n      disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    mutation EnablePullRequestAutoMerge(\n      $pullRequestId: ID!\n      $mergeMethod: PullRequestMergeMethod!\n    ) {\n      enablePullRequestAutoMerge(\n        input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }\n      ) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    mutation EnablePullRequestAutoMerge(\n      $pullRequestId: ID!\n      $mergeMethod: PullRequestMergeMethod!\n    ) {\n      enablePullRequestAutoMerge(\n        input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }\n      ) {\n        pullRequest {\n          number\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query AuthorId($author: String!) {\n      user(login: $author) {\n        id\n      }\n    }\n  ',
): (typeof documents)['\n    query AuthorId($author: String!) {\n      user(login: $author) {\n        id\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query CommitByPullNumber(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          # used to determine if "Rebase and Merge" strategy was used\n          commits(last: 1) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            oid\n\n            # used to determine if "Rebase and Merge" strategy was used\n            committedDate\n            history(first: 2) {\n              edges {\n                node {\n                  message\n                  committedDate\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query CommitByPullNumber(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          # used to determine if "Rebase and Merge" strategy was used\n          commits(last: 1) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            oid\n\n            # used to determine if "Rebase and Merge" strategy was used\n            committedDate\n            history(first: 2) {\n              edges {\n                node {\n                  message\n                  committedDate\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query CommitsBySha($repoOwner: String!, $repoName: String!, $sha: String!) {\n      repository(owner: $repoOwner, name: $repoName) {\n        object(expression: $sha) {\n          ...SourceCommitWithTargetPullRequestFragment\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query CommitsBySha($repoOwner: String!, $repoName: String!, $sha: String!) {\n      repository(owner: $repoOwner, name: $repoName) {\n        object(expression: $sha) {\n          ...SourceCommitWithTargetPullRequestFragment\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query CommitsByAuthor(\n      $authorId: ID\n      $commitPath: String\n      $dateSince: GitTimestamp\n      $dateUntil: GitTimestamp\n      $maxNumber: Int!\n      $repoName: String!\n      $repoOwner: String!\n      $sourceBranch: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $sourceBranch) {\n          target {\n            ... on Commit {\n              history(\n                first: $maxNumber\n                author: { id: $authorId }\n                path: $commitPath\n                since: $dateSince\n                until: $dateUntil\n              ) {\n                edges {\n                  node {\n                    ...SourceCommitWithTargetPullRequestFragment\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query CommitsByAuthor(\n      $authorId: ID\n      $commitPath: String\n      $dateSince: GitTimestamp\n      $dateUntil: GitTimestamp\n      $maxNumber: Int!\n      $repoName: String!\n      $repoOwner: String!\n      $sourceBranch: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $sourceBranch) {\n          target {\n            ... on Commit {\n              history(\n                first: $maxNumber\n                author: { id: $authorId }\n                path: $commitPath\n                since: $dateSince\n                until: $dateUntil\n              ) {\n                edges {\n                  node {\n                    ...SourceCommitWithTargetPullRequestFragment\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query CommitsForRebaseAndMergeStrategy(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n      $commitsTotalCount: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          number\n          commits(first: $commitsTotalCount) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            committedDate\n            history(first: $commitsTotalCount) {\n              edges {\n                node {\n                  oid\n                  message\n                  committedDate\n                  associatedPullRequests(first: 1) {\n                    edges {\n                      node {\n                        number\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query CommitsForRebaseAndMergeStrategy(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n      $commitsTotalCount: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          number\n          commits(first: $commitsTotalCount) {\n            totalCount\n            edges {\n              node {\n                commit {\n                  message\n                }\n              }\n            }\n          }\n\n          mergeCommit {\n            committedDate\n            history(first: $commitsTotalCount) {\n              edges {\n                node {\n                  oid\n                  message\n                  committedDate\n                  associatedPullRequests(first: 1) {\n                    edges {\n                      node {\n                        number\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query PullRequestBySearchQuery($query: String!, $maxNumber: Int!) {\n      search(query: $query, type: ISSUE, first: $maxNumber) {\n        nodes {\n          ... on PullRequest {\n            mergeCommit {\n              ...SourceCommitWithTargetPullRequestFragment\n            }\n          }\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query PullRequestBySearchQuery($query: String!, $maxNumber: Int!) {\n      search(query: $query, type: ISSUE, first: $maxNumber) {\n        nodes {\n          ... on PullRequest {\n            mergeCommit {\n              ...SourceCommitWithTargetPullRequestFragment\n            }\n          }\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query ExistingPullRequest(\n      $repoOwner: String!\n      $repoName: String!\n      $base: String!\n      $head: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        name\n        ref(qualifiedName: $head) {\n          name\n          associatedPullRequests(\n            first: 1\n            states: OPEN\n            baseRefName: $base\n            headRefName: $head\n          ) {\n            edges {\n              node {\n                number\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query ExistingPullRequest(\n      $repoOwner: String!\n      $repoName: String!\n      $base: String!\n      $head: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        name\n        ref(qualifiedName: $head) {\n          name\n          associatedPullRequests(\n            first: 1\n            states: OPEN\n            baseRefName: $base\n            headRefName: $head\n          ) {\n            edges {\n              node {\n                number\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query PullRequestAutoMergeMethod(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          autoMergeRequest {\n            enabledAt\n            mergeMethod\n          }\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query PullRequestAutoMergeMethod(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          autoMergeRequest {\n            enabledAt\n            mergeMethod\n          }\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query PullRequestId(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          id\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query PullRequestId(\n      $repoOwner: String!\n      $repoName: String!\n      $pullNumber: Int!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        pullRequest(number: $pullNumber) {\n          id\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n      query GithubConfigOptions($repoOwner: String!, $repoName: String!) {\n        viewer {\n          login\n        }\n        repository(owner: $repoOwner, name: $repoName) {\n          # check to see if a branch named "backport" exists\n          illegalBackportBranch: ref(qualifiedName: "refs/heads/backport") {\n            id\n          }\n          isPrivate\n          defaultBranchRef {\n            name\n            target {\n              ...RemoteConfigHistoryFragment\n            }\n          }\n        }\n      }\n    ',
): (typeof documents)['\n      query GithubConfigOptions($repoOwner: String!, $repoName: String!) {\n        viewer {\n          login\n        }\n        repository(owner: $repoOwner, name: $repoName) {\n          # check to see if a branch named "backport" exists\n          illegalBackportBranch: ref(qualifiedName: "refs/heads/backport") {\n            id\n          }\n          isPrivate\n          defaultBranchRef {\n            name\n            target {\n              ...RemoteConfigHistoryFragment\n            }\n          }\n        }\n      }\n    '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n      query RepoOwnerAndName($repoOwner: String!, $repoName: String!) {\n        repository(owner: $repoOwner, name: $repoName) {\n          isFork\n          name\n          owner {\n            login\n          }\n          parent {\n            owner {\n              login\n            }\n          }\n        }\n      }\n    ',
): (typeof documents)['\n      query RepoOwnerAndName($repoOwner: String!, $repoName: String!) {\n        repository(owner: $repoOwner, name: $repoName) {\n          isFork\n          name\n          owner {\n            login\n          }\n          parent {\n            owner {\n              login\n            }\n          }\n        }\n      }\n    '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetViewer {\n    viewer {\n      login\n    }\n  }\n',
): (typeof documents)['\n  query GetViewer {\n    viewer {\n      login\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetRepo($repoOwner: String!, $repoName: String!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      name\n    }\n  }\n',
): (typeof documents)['\n  query GetRepo($repoOwner: String!, $repoName: String!) {\n    repository(owner: $repoOwner, name: $repoName) {\n      name\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n    query GetBranchId(\n      $repoOwner: String!\n      $repoName: String!\n      $branchName: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $branchName) {\n          id\n        }\n      }\n    }\n  ',
): (typeof documents)['\n    query GetBranchId(\n      $repoOwner: String!\n      $repoName: String!\n      $branchName: String!\n    ) {\n      repository(owner: $repoOwner, name: $repoName) {\n        ref(qualifiedName: $branchName) {\n          id\n        }\n      }\n    }\n  '];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  fragment RemoteConfigHistoryFragment on Commit {\n    remoteConfigHistory: history(first: 1, path: ".backportrc.json") {\n      edges {\n        remoteConfig: node {\n          committedDate\n          file(path: ".backportrc.json") {\n            ... on TreeEntry {\n              object {\n                ... on Blob {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  fragment RemoteConfigHistoryFragment on Commit {\n    remoteConfigHistory: history(first: 1, path: ".backportrc.json") {\n      edges {\n        remoteConfig: node {\n          committedDate\n          file(path: ".backportrc.json") {\n            ... on TreeEntry {\n              object {\n                ... on Blob {\n                  text\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  fragment SourceCommitWithTargetPullRequestFragment on Commit {\n    # Source Commit\n    repository {\n      name\n      owner {\n        login\n      }\n    }\n    sha: oid\n    message\n    committedDate\n\n    author {\n      name\n      email\n    }\n\n    # Source pull request: PR where source commit was merged in\n    associatedPullRequests(first: 1) {\n      edges {\n        node {\n          title\n          url\n          number\n          labels(first: 50) {\n            nodes {\n              name\n            }\n          }\n          baseRefName\n\n          # source merge commit (the commit that actually went into the source branch)\n          mergeCommit {\n            ...RemoteConfigHistoryFragment\n            sha: oid\n            message\n          }\n\n          # (possible) backport pull requests referenced in the source pull request\n          timelineItems(last: 20, itemTypes: CROSS_REFERENCED_EVENT) {\n            edges {\n              node {\n                ... on CrossReferencedEvent {\n                  targetPullRequest: source {\n                    __typename\n\n                    # Target PRs (backport PRs)\n                    ... on PullRequest {\n                      # target merge commit: the backport commit that was merged into the target branch\n                      targetMergeCommit: mergeCommit {\n                        sha: oid\n                        message\n                      }\n                      repository {\n                        name\n                        owner {\n                          login\n                        }\n                      }\n                      url\n                      title\n                      state\n                      baseRefName\n                      number\n                      commits(first: 20) {\n                        edges {\n                          node {\n                            targetCommit: commit {\n                              message\n                              sha: oid\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  fragment SourceCommitWithTargetPullRequestFragment on Commit {\n    # Source Commit\n    repository {\n      name\n      owner {\n        login\n      }\n    }\n    sha: oid\n    message\n    committedDate\n\n    author {\n      name\n      email\n    }\n\n    # Source pull request: PR where source commit was merged in\n    associatedPullRequests(first: 1) {\n      edges {\n        node {\n          title\n          url\n          number\n          labels(first: 50) {\n            nodes {\n              name\n            }\n          }\n          baseRefName\n\n          # source merge commit (the commit that actually went into the source branch)\n          mergeCommit {\n            ...RemoteConfigHistoryFragment\n            sha: oid\n            message\n          }\n\n          # (possible) backport pull requests referenced in the source pull request\n          timelineItems(last: 20, itemTypes: CROSS_REFERENCED_EVENT) {\n            edges {\n              node {\n                ... on CrossReferencedEvent {\n                  targetPullRequest: source {\n                    __typename\n\n                    # Target PRs (backport PRs)\n                    ... on PullRequest {\n                      # target merge commit: the backport commit that was merged into the target branch\n                      targetMergeCommit: mergeCommit {\n                        sha: oid\n                        message\n                      }\n                      repository {\n                        name\n                        owner {\n                          login\n                        }\n                      }\n                      url\n                      title\n                      state\n                      baseRefName\n                      number\n                      commits(first: 20) {\n                        edges {\n                          node {\n                            targetCommit: commit {\n                              message\n                              sha: oid\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n'];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> =
  TDocumentNode extends DocumentNode<infer TType, any> ? TType : never;
